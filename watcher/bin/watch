#!/usr/bin/env ruby
require 'net/http'
require 'io/console'
# require 'aws-sdk'


class PifaceStub

  def write(output_pin, value)
    puts "DEBUG: Setting pin #{output_pin} to #{value}"
  end

  def read(*)
    key_is_down = self.getkey != nil
    return key_is_down ? 1 : 0
  end

  # Return the ASCII code last key pressed, or nil if none
  def getkey
    char = nil
    begin
      system('stty raw -echo') # => Raw mode, no echo
      char = (STDIN.read_nonblock(1).ord rescue nil)
    ensure
      system('stty -raw echo') # => Reset terminal mode
    end
    return char
  end

end


begin
  # noinspection RubyResolve
  require 'piface'
  $piface = Piface
  $devmode = false
rescue LoadError
  $piface = PifaceStub.new
  $devmode = true
end


class Tracker

  # Max time between clicks, reset the count to 0 if exceeded
  TIMEOUT = 5

  def initialize( piface, led, deployer, revs_to_deploy )
    @piface = piface
    @led = led
    @deployer = deployer
    @revs_to_deploy = revs_to_deploy
    @last_button_state = 0
    @click_count = 0
    @last_click_time = Time.now
  end

  def process_frame
    state = @piface.read(0)
    if @last_button_state != state
      if state == 1
        self.click
        sleep 0.02
      end
    end
    @last_button_state = state
  end

  def click
    if @last_click_time < (Time.now - TIMEOUT)
      self.restart
      puts "Restarting. You must revolve at least once every #{TIMEOUT} seconds."
    else
      @click_count += 1
      puts self.status_message
      if @click_count < @revs_to_deploy
        @led.set(:inprogress, @click_count % 2)
      elsif @click_count == @revs_to_deploy
        self.succeed
      end
    end
    @last_click_time = Time.now
  end

  def restart
    @click_count = 0
    @led.reset
  end

  def succeed
    @led.enable(:success)
    @deployer.deploy
    @deployer.take_photo
  end


  def status_message
    if @click_count == 0
      return "Let's to this! You have to go #{@revs_to_deploy} revolutions to deploy."
    end
    if @revs_to_deploy - @click_count == 0
      return "You've done it! A deploy is on its way."
    end
    if @revs_to_deploy - @click_count < 0
      return nil
    end
    if @click_count % 5 == 0
      return "You've gone #{@click_count} revs, #{@revs_to_deploy - @click_count} to go."
    end
    return nil
  end
end


class Deployer

  def initialize(dryrun)
    @dryrun = dryrun
  end

  def deploy
    uri = URI('http://ci.int.cozy.co/go/api/pipelines/velopsipede/schedule')
    http = Net::HTTP.new(uri.host, uri.port)
    request = Net::HTTP::Post.new(uri.request_uri)
    if @dryrun
      puts "Would deploy to #{uri.to_s}"
    else
      http.request(request)
    end
  end


  def take_photo
    time = Time.now.strftime('%Y-%m-%d_%H-%M-%S')
    filename = "/home/pi/photos/pederplerer-#{time}.jpg"
    if @dryrun
      puts "Would take a photo saved to #{filename}"
    else
      `fswebcam -r 1280x720 --no-banner #{filename}`
    end

#  s3 = Aws::S3::Resource.new(region:'us-west-2')
#  obj = s3.bucket('bikeface').object(filename)
#  obj.upload_file(filename, {:acl => 'public-read'})
  end

end


class LED

  NAME_TO_PIN_NUMBER = {
    success: 0, # green LED
    inprogress: 1 # yellow LED
  }

  def initialize(piface)
    @piface = piface
  end

  def set(name, value)
    pin = NAME_TO_PIN_NUMBER[name]
    @piface.write(pin, value)
  end

  def enable(name)
    self.set(name, 1)
  end

  def disable(name)
    self.set(name, 0)
  end

  def reset
    NAME_TO_PIN_NUMBER.keys.each do |name|
      self.disable(name)
    end
  end

end


def main
  led = LED.new($piface)
  deployer = Deployer.new($devmode)
  units_to_deploy = (ARGV.first || 100).to_i
  tracker = Tracker.new( $piface, led, deployer, units_to_deploy )
  led.reset
  at_exit do
    led.reset
  end
  puts tracker.status_message
  loop do
    tracker.process_frame
    sleep 0.001
  end
end

main
